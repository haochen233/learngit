	Go语言区别于其他语言的一大特色就是支持并发编程模式，Go语言使用了关
键字go，通过Goroutine实现了程序的并发设计。
	使用Go语言开发服务器端程序时，就需要对它的并发机制有深入了解。

10.1 程序并发执行概述
	在多任务操作系统中，进程和线程的执行具有并发性，并发是指在一段时间
内，多个任务可以共享系统资源，同时执行。而并行是指从某个时刻开始，多个
任务同时执行。
	
	10.1.1 程序的顺序执行
		内存中只有一道程序作业在执行。一个程序作业完成后，下一个程序才
	能进入内存中来继续执行，这样一来，计算机上程序的执行过程就严格的按
	照顺序方法进行。
		顺序执行的特点概括起来就是程序的封闭性和可再现性，封闭性就是程序
	的计算结果只取决于程序本身。可再现性是同一程序可以反复执行。
	
	10.1.2 程序的并发执行
		所谓并发执行就是指同一时间间隔内，多个程序可以"同时"执行
		在单处理器系统上，通过时间片来实现任务切换，以达到同时运行的
	目的。微观上还是一个接一个执行的，但是因为每个程序执行的时间都
	非常的短，所以从宏观上看是“同时执行”。
		程序的并发使得多个程序可以共享系统资源，提高系统资源利用率，
	还可以增加系统吞吐量。它产生了新的特征。
	（1）失去了封闭性，多个程序共享系统资源，在并发环境下，由于各个
	程序运行的快慢不同，可能会导致读取数据出错的问题。导致程序结果
	出错。
	（2）失去了可再现性。程序是指令的有序集合，是“静态”的概念，而计算
	是指令序列在处理机上的执行过程，是动态的概念。在并发执行中，一个
	共享程序可能被多个用户作业调用，从而产生多个结果。
	（3）并发程序间的制约性
		即同步关系。
	
	10.1.3 程序的并行执行
		和并发程序不同，程序的并行执行是指同一时刻，多个程序可以同时
	执行。
		在多处理器系统上，可以达到并行。
		
10.2 Goroutine
	程序的并发执行基本上是由操作系统提供的，很少有在语言层面就支持并发
特性的，而Go语言就可以在语言层面支持并发模式的程序。
	
	10.2.1 操作系统提供的并发基础
		程序并发执行的基础是进程(process)、线程(Thread)、协程(Corouti
		nue)
		
		1、进程
			进程是环境下，程序的一次动态的执行过程，它由进程控制块、
		程序和数据三部分组成。由三种状态：就绪、运行、阻塞三种基本
		状态。
			在多任务操作系统中，多个进程可以并发执行，而且进程是操作
		系统资源分配的基本单位。
			进程之间是独立的，且互不影响，但缺点是系统开销大。所以进
		程同时创建的数量是有限的。
		
		2、线程
			由于进程的开销大，所以设计出了更小的能独立运行的单位——线
		程，从而进一步提高系统的吞吐量。
			线程都是由进程创建的，它继承了进程的部分资源，且具有进程
		的一些基本特征，所以多个线程也可以并发执行。且比进程开销小。
		但是和进程一样，线程依然是由系统内核管理的，所以在高并发模式
		下，系统能够创建的线程数量依然有限，效率也不高。
		
		3、协程
			协程本质上是一种用户态线程，不需要操作系统进行抢占式调度
		，而且在真正的实现中寄存于线程中，因此，协程系统开销极小，可
		以有效提高线程任务的并发性，协程最大的优势在与“轻量级”，可以
		轻松创建上百万个而不会导致系统资源衰竭，而系统最多能创建的进程
		、线程数量却少的多
			协程的优点是编程简单，结构清晰。但缺点是需要语言的支持，如
		果语言不支持，则需要用户在程序中自行实现调度。
		
	10.2.2 Goroutine的定义	
		Go语言在语言级别支持轻量级线程，叫作Goroutine。Go语言标准库提
	供的所有系统调用操作，都会让出处理器给其他Goroutine，这使得轻量级
	线程的切换管理不依赖于系统的进程和线程，也不依赖与Cpu的核心数量。
		Goroutine是Go语言运行库的功能，不是操作系统提供的功能，不是用
	线程实现的。Goroutine就是一段代码，一个函数入口，以及在堆上为其分
	配的一个堆栈。因为节省了频繁创建和销毁线程的开销，所以它相对于线程
	开销非常小，可以轻松创建上百万个，但他们并不是被操作系统所调度执行
	。
	
	10.2.3 Goroutine的创建
		Goroutine是Go语言中的轻量级线程实现，由Go运行时管理（Runtime）
	在一个函数前加上关键字“go”，这次调用就会在一个新的Goroutine中并发
	执行。当被调用的函数返回时，这个Goroutine就自动结束了，需要注意的
	是：如果这个函数有返回值，那么这个返回值会被丢弃。
	
		基本格式如下：
		go func()
		
		例如：
		func main() {
			for i := 0; i < 10; i++ {
				go test()
			}
		}

		func test() {
			Println("Goroutine Hello golang")
		}
		
		共调用了10次test函数，它们是并发执行的，但是当我们编译执行该
	程序时，发现并没有输出。
		这是因为，程序从main函数开始，当mian函数返回时程序退出，并且
	程序不等待其他Goroutine结束，即main函数返回前，这10个Goroutine还没
	来得及执行，所以导致了没有输出结果。
		个人经验总结：这就类似学习僵尸进程时，父进程没有等待子进程直接
	退出了，还有主线程为等待其他线程执行完毕就退出了。
		C语言有线程等待join，进程有wait，那么Go语言也有自己的方式，那
	就是Channel（通道）。Channel可以在Goroutine之间进行通信，这样main
	函数就可以知道Goroutine何时退出，利用Channel，main()函数就可以等待
	所有Goroutine都退出了自己再退出。
		
	通常Goroutine和Channel配合使用，二者缺一不可。
	
10.3 Channel 
	1、共享内存
	
	2、消息机制
	
	10.3.2 Channel简介
		Go语言提供的消息通信机制被称为Channel，它类似于单双向管道(pipe
	)，用户可以使用Channel在两个或多个Goroutine之间传递消息。Channel会
	从设计上确保只有一个Goroutine能从中接收数据，这就避免了使用互斥	的问题。另外，Channel中数据的发送和接收都是原语操作（即原子操作，具有不可分割性，不可中断性），不会中断，只
	会失败。
		Channel是进程内的通信方式。
	
	10.3.3 Channel声明和初始化
		在Go语言中，Channel是引用类型，也是类型相关的，也就是说一个Cha
	nnel只能传递一种类型的值，这个类型需要在声明Channel时指定。Channel
	的声明格式如下：
		var chanName chan ElementType
		
		例如：
		var ch1 chan int
		ch1是一个传递int类型的Channel
		
		Channel 除了可以传递基本类型的数据，还可以作为Array、Map和Slic
	e的元素。
		
		例如：
		var chs []chan int 
		该例表示，chs是一个包含10个可传递int类型数据的Channel。
		
		好可以使用make()函数声明并初始化Channel
		例如：
		
		ch2 := make(chan, int)
		
	10.3.4 数据接收和发送
		Channel的主要用途是在不同的Goroutine之间传递数据。
		使用通道运算符“<-”接收或者发送数据，将一个数据发送(写入)至Chan
	nel的语法如下：
		ch <- value
		
		向Channel写入数据通常会导致程序阻塞(Block)，直到有其他Goroutin
	e从这个Channel中读取数据。从Channel中接收（读取）数据的语法如下：
		value := <- ch
		
		如果Channel之前没有写入数据，那么从Channel中读取数据也会导致阻
	塞。直到Channel中被写入数据为止。
		
	10.3.5 Channel的关闭和迭代器
		关闭Channel使用Go语言内置函数close()即可。关闭Channel的操作语
	句如下：
		close(chanName)
	
		在关闭一个Channel之后，往往用户还需判断Channel是否被关闭
	
			/*Channel的迭代操作*/                   
			ch := make(chan int)               
			go func() {                        
				for i := 0; i < 5; i++ {       
					ch <- i                    
				}                              
				//记住关闭，否则下面range遍历出问题          
				close(ch)                      
			}()                                
											   
			for value := range ch {            
				Print(value, ",")              
			}                                  
											   
			//返回false表示已关闭                     
			_, ok := <-ch                      
			if !ok {                           
											   
				Println("close successed")     
			}                                  
			
			结果0,1,2,3,4, close successed
	
		只有发送方才能关闭Channel，只有接收端才能获得关闭状态。
	close调用不是必须的，但是接收端使用range或者循环接收数据，
	就必须调用close，否则会导致出错。
	
	10.3.6 单向Channel
		前面的例子中列举的通道既能发送数据也能接收数据。被称为双向
	通道（Duplex-channel）。
		还可以将Channel指定为单向通道（Simplex-channel）,即只能接收
	，或只能发送。
	
		只能接收的Channel变量定义形式如下：
		var chanName chan <- ElementType
		
		只能发送的Channel变量定义形式如下：
		var chanName <- chan ElementType
		
	同时单向Channel还可以通过双向Channel经过类型转换得来
		例如：
			var c1 = make(chan int)
			c2 := chan <-(c1)
			c3 := <- chan(c1)
			
			//c1为双向，c2为只读，c3为只写
	
	
	
	