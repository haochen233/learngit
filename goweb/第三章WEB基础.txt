3.1 Web工作的方式
	浏览器就是一个客户端，输入URL时，浏览器会请求DNS服务器，通过该服务寻
找响应的域名对应的IP，然后根据IP地址找到对应的服务器后，要求建立TCP连接
，等浏览器发送完HTTPRequest(请求)包后，服务器接收请求包之后开始处理请求
包，服务器调用自身服务，返回HTTP Resopnse(响应)包;客户端收到来自服务器的响
应后开始渲染这个Response包里的主体(body)，等收到全部内容随后断开与该服务器
之间的TCP连接。

	简单的归纳为几个步骤：
	1、客户端通过TCP/IP协议建立到服务器的连接。
	2、客户端向服务器端发送HTTP Request包，请求服务器里面的资源文档。
	3、服务器端向客户端发送HTTP Response包，如果请求的资源包含有动态语言的
内容，那么服务器会调用动态语言的解释引擎负责处理该动态资源，并将处理的内容
返回给客户端。
	4、客户端与服务器端断开连接，有客户端解释HTML文档，在客户端屏幕上渲染
图形效果。
	
	一个简单的HTTP事务就是这样实现的，注意：客户端与服务器端的通信是非持久
连接的，也就是说当服务器端发送了应答包后就与客户端断开了连接，等待下一次请
求。

	
URL和DNS解析：
	URL(Uniform Resource Locator)是“统一资源定位符”的缩写，用于描述一个
网络上的资源。
	一般格式如下：
	schema://host[:port#]/path/.../[?query-string][#anchor]
	
	schema   指底层使用的协议如：http，https，ftp
	host 	 http服务器的ip地址或域名
	port#	 http服务器的默认端口是80，可以省略，如用其他端口必须指明。
	path 	 访问资源的路径
	query-string  发送给http服务器的数据
	anchor	 锚
	
	DNS（Domain Name System）是域名系统的缩写，它将主机名或域名转换为ip
地址。
	
HTTP协议详解
	HTTP协议是Web工作的核心
	它建立在TCP协议之上，它是一个请求、响应协议——客户端发送一个请求，服
务器响应这个请求。
	在HTTP中，客户端总是通过建立一个连接与发送一个HTTP请求来发起一个事务
。服务器不能主动和客户端联系。客户端与服务器端都可以提前中断一个连接。
	HTTP是无状态的，同一个客户端的这次请求和上次请求是没有对应关系的。对
与HTTP服务器来说，它是不知道这两个请求时来自同一个人客户端，为了解决这个
问题，Web程序引入了Cookie机制来维护连接的可持续状态。
	因为HTTP协议是建立在TCP协议上的，所以TCP攻击一样会影响HTTP通信，例如
一些常见的攻击，SYN Flood是当前最流行的Dos（拒绝服务攻击）与Ddos（分布式
拒绝服务攻击）的方式之一，利用TCP协议缺陷，发送大量伪造的TCP连接请求，从
而使被攻击方资源耗尽（CPU或内存不足）的攻击方式。
	因为没保持一个半连接都需要存储空间来存储这些信息，随着这些半连接越来
越多，服务器的内存将被耗尽，正常用户的请求不能进来。
-----------------------------------------------------------------------
HTTP请求包（浏览器信息）
	Request包分为三部分，第一部分为Request line（请求行）、第二部分是Req
uest header（请求头），第三部分是body（主体）。header与body之间有个空行
	例如如下结构：
	GET	/domains/example/ HTTP/1.1		//请求行：请求方法 请求的URL HTTP协议/协议版本
	Host: www.iana.org 		//服务器的主机名
	User-Agent：Mozilla/5.0 （Windows NT 6.1）//用户代理（浏览器）
	...
	//空行
	//消息体（body）
	
	GET请求的消息体为空，POST请求带有消息体
	HTTP协议定义了很多与服务器交互的请求方法，最基本的有四种，分别是GET、
POST、PUT、DELETE。一个URL地址用于描述一个网络上的资源，而HTTP中的GET、P
OST、PUT、DELETE就对应着对这个资源的查、改、增、删4个操作。
	常见的就是GET和POST了，GET一般用于获取/查询资源信息，而POST用于更新
资源信息。
	GET与POST的区别：
	1、GET提交的数据会放在URL之后，以？分割URL和传输数据，参数之间以&相
连。例如：EditPosts.aspx?name=test1&id=123456。而POST方法是把提交的数据
放在HTTP包的Body中。
	2、GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法
是把提交的数据放在HTTP包的body中没有大小限制。
	3、GET方式提交数据，会带来安全问题，比如一个登陆界面，通过GET方式提交
数据，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台
机器，就可以从历史记录获得该用户的账号和密码。

-----------------------------------------------------------------------
HTTP响应包（服务器信息）
HTTP响应包，它的结构如下：

HTTP/1.1	200 OK		//状态行
Server： nginx/1.0.8	//服务器使用的WEB软件名及版本
Date：Date：Tue, 30 OCT 2019 11:25:26 GMT 	//发送时间
Content-Type：text/html	//服务器发送信息的类型
Transfer-Encoding：chunked	//表示发送HTTP包是分段发的
Connection：keep-alive 	//保持连接状态
Content-Length: 90		//主体内容长度	
//空行用来分割消息头和主体
//消息体

	Response包中的第一行叫作状态行，有http协议版本号，状态码，状态消息组
成。状态码用来告诉HTTP客户端，HTTP服务器是否产生了预期的Response。
	HTTP/1.1协议中定义了5类状态码，状态码由三位数字组成，第一个数字定义了
响应的类别
	# 1XX 提示信息——表示请求已经被接收，继续处理。
	# 2XX 成功——表示请求已经被成功接收，理解，接受。
	# 3XX 重定向——要完成的请求必须进行更进一步的处理。
	# 4XX 客户端错误——请求有语法错误或请求无法实现。
	# 5XX 服务器端错误——服务器未能实现合法的请求。
	
-----------------------------------------------------------------------
HTTP协议是无状态的和Connection：keep-alive的区别
	无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态
。HTTP是一个无状态的面向连接的协议。
	从HTTP/1.1起，默认开启了Keep-Alive保持连接特性，简单地说，当一个网页
打开完成后，客户端和服务器值之间用于传输HTTP数据的TCP连接不会关闭，如果
客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的TCP连接。
	Keep-Alive不会永久保持连接，它由一个保持时间，可以在不同服务器软件（
如Apache）中设置这个时间。
	
-----------------------------------------------------------------------
请求实例
	第一次请求url，服务器端返回的是HTML页面，然后浏览器开始渲染HTML，当
解析到HTML里面的图片链接和Css脚本和js脚本的链接，浏览器就会自动发起一个
请求静态资源的HTTP请求，获取对应的静态资源，然后浏览器就会渲染出来，最终
将所有的资源整合，完整的展现在我们的屏幕上。

	网页优化方面有一项措施就是减少HTTP请求次数，把尽量多的css和js资源合并
在一起，目的是减少请求静态资源的次数，提高网页加载速度，同时减缓服务器压力

-------------------------------------------------------------------------
3.3 Go如何使得Web工作
	
-------------------------------------------------------------------------
Web工作方式的几个概念
	以下为服务器端的几个概念
	Request：用户请求的信息，用来解析用户的请求信息，包括post、get、url
cookie等信息
	Response：服务器需要反馈给客户端的信息
	Conn：用户的每次连接请求
	Handler：处理请求和生成返回信息的处理逻辑
	
	http包执行流程
		1、创建Listen Socket，监听指定的端口，等待客户端请求的到来。
		2、Listen Socket接受客户端的请求，得到Client Socket，通过Client
	Socket与客户端通信。
		3、处理客户端的请求，首先从Client Socket读取HTTP请求的协议头，如
	果是POST方法，还可能要读取客户端提交的数据，然后交给相应的Handler处
	理请求，Handler处理完毕后准备好客户端需要的数据，通过Client Socket写
	给客户端。
		
		需要清楚三个问题：
		第一个问题：如何监听端口
		第二个问题：如何接收客户端请求
		第三个问题：如何分配handler
		
		Go是通过一个函数ListenAndServer来处理这些事情。
		底层是这样处理的：初始化一个server对象，然后调用net.Listen("tcp",
	 addr),就是用tcp搭建了一个服务，然后监听端口。
		监控之后如何接收客户端的请求呢？，监控之后，调用了srv.Serve(net.L
	istener)函数，这个函数接收客户端的请求信息，在这个函数中起了一个for
	循环用这个Listener对象循环Accept，成功即生成一个Conn对象，然后为了高
	并发，将该Conn对象（数据）作为参数生成新的Conn对象，然后将该连接对象的
	服务，作为Goroutine启动，这样就实现了高并发。
		如何具体分配相应的函数来处理请求呢。
		进入这个Goroutine，调用ReadRequest方法，然后获取相应的handler，然后
	因为我们在ListenAndServer的第二个参数传的是nil，所以handler默认是Defaul
	tServeMux，这个变量时什么呢，它是一个路由器，它用来匹配url跳转到相应
	的handle函数，因为我们在main函数的第一行调用了HandleFun("/",sayhelloNam
	e),这就相当于注册了请求"/"的路由规则，所以当请求uri为"/"时，路由就会转
	到函数sayhelloName，DefaultServeMux会调用ServeHTTP方法，这个方法内部就是
	调用sayhelloName本身。
		最后通过写入response的信息反馈到客户端。
		