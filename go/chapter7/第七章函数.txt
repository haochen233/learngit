7.1 函数声明
	在GO语言中，函数在声明之后就可以使用，无需声明函数原型。Go函数一般
由关键字func、函数名、参数列表、返回值和返回语句组成。当然，有些函数没
有返回值。

	7.1.1 函数声明基本格式
		GO语言属于静态语言，如变量必须先声明后使用一样，函数在被调用之
	前必须要先声明，否则Go编译器无法识别。
		格式如下:
			func functionName (参数列表) 返回值{
				functionBody
				.
				.
				.
				return 语句
			}
		在声明函数时要注意：
		（1）函数名的命名规则与变量名相同，遵循标识符命名规则。
		（2）函数可以有参数或者没有参数。
		（3）函数体内的所有语句使用{}括起来,左大括号必须和func放在同一行，
		右大括号必须要单独占一行。
		（4）函数会在执行完最后一条语句，或执行return语句后结束。Go语言
		支持多返回值。另外，在终止一个无限循环或goroutine时通常也使用retu
		rn语句。
		
	7.1.2 函数声明举例
		例如无参且无返回值的函数声明：
			func f1(){
				fmt.Println("Hello world")
			}
			
		例如有参数但无敌返回值的函数声明：
			func f2(a int, b int, c string){
				Println(a, b, c)
			}
			
		在函数声明时，如果多个参数类型一致，可以采用复合定义的
	方式。
			即
			func f2(a,b int, c string){
				Println(a, b, c)
			}
			
		例如有参有一个返回值：
			func f3(a, b int) int {
				return a + b
			}
		
		例如有参有多个返回值：
			func f4(a, b int) (ret float32, err error) {
				if b == 0 {
					err = errors.New("overflow!")
					return
				} else {
					return float32(a) / float32(b), nil
				}
			}

7.2 函数调用
	在Go语言中，程序时以包为基本单位来组织的，函数都属于某个包，
所以函数在调用时依据它所属的包不同，分为以下几种情况：
	（1）调用内置函数。Go语言提供了13个内置函数，函数名均为小写
	，这些函数都可以直接调用，无须导入任何外部包。
	（2）调用标准包中的函数
	（3）调用一个自定义函数，且与主调函数在同一个包中。
	（4）被调用的函数由用户创建的包提供。
	
	第二种和第四种情况都来自于外部包，而且函数名第一个字母都为
大写。在这种情况下，在调用一个人函数前都要首先导入外部包，然后
才能正常调用。调用的格式为：
	import "packageName"
	packageName.functionName(参数)
	
	第三种情况属于被调函数和主调函数处于同一个包中，可以直接调
用，而且函数名一般是小写，调用格式为：
	functionName(参数)
	
	7.2.1 调用标准函数
		常用的标准包包括 fmt、math、os、time、bytes等，标准包的
	信息可以在Go安装目录的pkg下查看，或使用godoc查看。
	
	7.2.2 调用一个自定义函数
		略。
	
	7.2.3 调用外部包中的函数
		首先构建一个mymath包，它提供了Add()、Sub()、Mult()、
	Div() 4个函数，遵循GO语言的可见性原则，这些函数首字母必须
	大写。main包中要调用这些函数，只需在调用前导入mymath包即可
	。
	
	7.2.4 调用内置函数
		这些函数都可以直接使用，无须导入任何包。内置函数一般都
	能对不同的数据类型进行操作，比如len()函数能获取数组、字符串
	、切片的长度。Go语言的内置函数不多但是都非常有用。
	
	
7.3 参数传递和返回值	
	在Go语言中，函数参数可以是值类型或引用类型，值类型作为	
函数参数传递时，是一个参数值的拷贝，引用类型作为参数传递时	
，是一个地址拷贝。	
	Go语言中的函数被调用时，允许有返回值，甚至多个返回值。	
GO语言还允许定义返回值变量，这样在使用return语句进行返回时	
语句更加简洁。	
	
	7.3.1 参数传递
		说明：
			（1）...
			（2）...
			（3）在声明函数时，必须指定形参的类型，而且实参与
			形参的类型必须一致。
		
		1、常规传递
			当使用普通变量作为函数参数时，在传递参数时只是对变量
		值的拷贝，当函数对形参进行处理时，并不会影响原来实参的值。
		
		2、指针传递
			将实参的内存地址复制给形参，这时对形参的修改也将会
		影响到实参的值。
			跟C语言一样。
			
			/*指针传递*/
			func f5(a *int) {
				*a = 666
			}
	
		3、数组元素作为函数参数
			当使用数组元素作为函数参数时，其使用方法和普通变量
		相同，是值拷贝。
		
		4、数组名作为函数参数
			与C语言相反，传递的数组是数组的拷贝，在函数中对数组
		元素的拷贝并不会影响原数组元素。
			实参的数组长度必须与形参指定的长度相同。
			
			/*数组名作为函数参数*/
			func f6(a [5]int) {
				a[0] += 1
				Println(a[0])
			}
		5、Slice作为函数参数
			当希望通过形参对底层数组进行修改时，可以使用slice
		作为函数参数。在使用时，传递的将是一个地址拷贝，这时对
		slice元素的操作即是对底层操作元素的操作。
			
			/*Slice作为函数参数*/
			func f7(a []int) {
				a[0] = 666
			}
		
		6、函数作为参数
			类似C语言中的函数指针
			
			/*函数作为参数*/
			func f8(a, b int, sum func(int, int) int) {
				Println(sum(a, b))
			}

			func sum(a, b int) int {
				return a + b
			}
			
	7.3.2 返回值
		带返回值的函数在声明的时候同时要定义返回值的类型，返回值
	的类型可以是Go语言支持的基本数据类型。
		
		1、return语句
			略。
		
		2、多返回值
			这和C语言不同，多返回值使Go程序设计起来更加灵活，而且
		功能强大。如果函数定义了多个返回值，除了说明各个返回值的
		类型外，还需使用一对括号将它们括起来。
		
		3、返回值的忽略
			可以使用标识符"_"将不需要的忽略。
		
		4、命名返回值参数
			/*命名返回值参数,sum,sub*/
			func f9(a, b, int) (sum, sub int) {
				sum = a + b
				sub = a - b
				return
			}	
			Go语言还支持命名返回值参数，如果使用命名返回值参数，则
		return语句可以为空，就能向主调函数返回sum、sub。如果未命名
		返回值参数，函数f9()的返回语句写法是：return a+b,a-b

7.4 变参函数
	一般地，函数中形式参数的数目是确定的，在调用时要依次传递与
形式参数对应的所有实际参数，但在某些情况下希望函数的参数个数可
以根据实际需要来确定，这就是变参函数。最典型的变参函数由Printf
、Scanf()等。
	
	7.4.1 变参函数的声明
		Go语言支持不定长变参，但需要注意不定长变参只能作为函数
	的最后一个参数（与c++参数默认值类似），不能放在其他参数的
	前面。
		声明格式如下：
		func functionName(variableArgumentName ... dataType)返回值{
			functionBody
			.
			.
			.
		}
		
		例：
		func f10(args ...int) {
			for _, v := range args {
				Println(v)
			}
		}
		
		注意：
		（1）变参必须是函数的最后一个参数。其他参数必须在变参之前
		（2）不定长变参其实质就是一个切片，可以使用range遍历
		
	7.4.2 变参的传递
		/*声明f11、f12为变参函数*/
		func f11(args ...int) {
			f12(args...)

			f12(args[:2]...)
		}

		func f12(args ...int) {
			Println(args)
		}
		
		不定长变参在进行参数传递时虽然接收到的是一个Slice，但是和
	直接传递一个Slice还是有区别的，直接传递Slice是“地址拷贝”可以修
	改外面Slice，但是不定长变参在传递一个Slice时，仅仅是置传递。
	
	7.4.3 任意类型的变参
		前面说的变参都是同一种类型，比如同为整型、浮点型、字符串等
	。在实际应用中，用户希望传递不同类型的参数，比如向Printf函数那
	样。
		Go语言规定，如果希望传递任意类型的变参，变参类型应指定为空
	接口interface{}。
	
	例如：
		func f1(args ...interface{}){
			.
			.
			.
		}
	
		在GO语言中。空接口interface{}可以指向任何数据对象，所以使用
	interface{}定义任意类型变参。同时，interface{}也是类型安全的。
	
7.5 匿名函数与闭包
	
	7.5.1 匿名函数
		匿名函数是指不需要定义函数名的一种函数实现方式。
		在Go语言中，函数可以像变量一样被传递和使用，这与C语言的
	回调函数比较类似。
		Go语言支持随时在代码里定义匿名函数。匿名函数由一个不带函
	数名的函数声明和函数体组成。
		格式如下：
			func (参数列表)返回值{
				functionBody
				.
				.
				.
				return 语句
			}
			
		例如：
			func (a,b int) int{
				return a+b
			}
			
		注意：在Go语言中，使用匿名函数时要注意它不能作为顶级函数
		，而只能放在其他函数体中，比如main函数等等，即它必须有一
		个外层函数。
		
		7.5.2 闭包
			函数闭包的返回值是匿名函数
			闭包（Closure），就是内部函数通过某种方式使其可见范围
		超出了其定义的范围。
			例如：
				func main (){
					f := closures(624)
					Println(f(1))
					Println(f(2))
				}
				
				/*函数闭包,返回值是一个函数类型*/
				func closures(x int) func(int) int {
					return func(y int) int {
						return x + y
					}
				}
				
				//输出结果是625 与 626
			函数闭包主要有一下几个作用：
			（1）函数闭包能够保护函数内的变量安全，比如上例
			中的closures函数中的参数x，只有内部函数能够访问
			，而无法通过其他途径。
			（2）函数闭包可以在内存中维持一个变量，就如上例
			中，x被初始化为624，然后一直保持这个值，后面无论
			怎么调用f，x在内存中一直存在。
			
7.6 函数的递归调用和defer语句
	
	7.6.1 函数的递归调用
		递归调用不应该出现无终止的递归调用，只应出现有限次的
	、有终止的递归调用。
	
	7.6.2 defer语句
		在Go语言中，可以使用关键字defer向函数注册退出调用，即
	当主调函数退出时，defer语句后的函数才会被调用。defer的作用
	时不管程序是否出现异常，均在函数退出时自动执行相关代码。
		/*defer语句test*/
		/*	defer Println("I am first")
			Println("I am second")
		*/
		
		输出为：
			I am second
 			I am first
		
		1、defer语句实现逆序调用
			如果程序中有多个defer语句，则按照先进后出（FILO）
		的次序执行，即最后一个定义的defer语句先执行。
		
		2、defer语句支持匿名函数调用
		/*defer语句声明时的变量的值，就是最后执行defer语句的值*/
		func f14() {
			i := 0
			defer Println(i)
			i = 66
		}
		
		执行f14的结果为 0
		
		/*被延迟的匿名函数会读取外部函数的返回值，并且对外部函数的返回值赋值*/
		func f15() (i int) {
			defer func() {
				i++
			}()
			i = 1
			return
		}
		
		输出结果为5。
		
		3、defer语句用于清理工作 
			在Go程序中，当程序返回或发生异常时，defer语句通常
		用来做一些函数调用后的清理工作，释放资源变量。
		比如，关闭文件描述符，关闭互斥锁；
		
			defer语句的用法有两个优点：
			（1）让设计者永远也不会忘记关闭文件，有时函数返回
			时常常忘记释放打开的资源变量。
			（2）将打开和关闭靠在一起，程序的意图也变的清晰很多。
		
	7.6.3 异常恢复机制
		panic-and-recover机制
		panic是一个内置函数，可以中断原有的控制流程，进入一个
	异常流程。
		Recover是一个内置的函数，它可以让进入异常流程中的goroutine
	恢复过来。Recover仅在延迟函数中有效。
	
	
		